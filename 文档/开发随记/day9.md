今日计划

​	选课

​	严重bug，当管理端和学生端同时操作时，会出现数据丢失的情况



今天做了什么

​	新增课程时，下拉列表选择教师时显示教师姓名1

​	

​	优化：在新增选课任务的课程代码下拉列表中，同时显示课程代码和课程名称1



​	选课页面数据获取，不是通过课程表by  Seckill=1

​		是根据seckill_tasks表的记录来获取的1

​	

​	获取的时候观察时间，分为未开始，抢课中，已结束三个阶段1

​		前端定时轮询获取数据，以判断阶段

​		前端添加一个单选框：仅看抢课中

​		对于未开始和已结束阶段没有选课按钮

​		详情中显示抢课开始时间、结束时间、余额、抢课状态（这些要显示在页面中）

​		点击抢课按钮后开始抢课逻辑

​	

​	限时选课逻辑

​		点击选课按钮

​			禁用选课按钮，防止重复点击1

​			设置超时

​			点击秒杀时，获取动态请求地址1

​			根据 动态path 发送 秒杀请求	1

​		秒杀结果监听

​			前端显示等待页面

​			检查是否超时

​			发送 监听秒杀结果请求，去处理结果

​			前端显示选课成功/选课失败

​			清楚定时器

​	

​	后端

​		应用启动时，缓存秒杀数据（如：库存到Redis中）	1

​			页面获取秒杀数据时先去Redis中找		1



​		获取动态秒杀地址		SeckillServiceImpl	createSeckillPath		1

​			生成随机字符串

​			将path存入Redis中，设置有效期

​		

​		秒杀

​			验证path					1

​				从Redis中获取path

​				安全比较

​				验证比较重置path过期时间

​			检查重复秒杀			1

​				用到三级缓存（本地内存，Redis，DB）

​				判断本地内存

​				判断Redis，回写本地内存

​				判断数据库，回写本地内存和Redis

​			核心秒杀		1

​				从Redis中拿到库存数据

​				第一次判断库存

​				Redis预减库存

​				第二次判断

​				更新缓存状态（本地内存和数据库，以方便检查重复秒杀）



​		异步MQ。写入数据库(selections表，student_id,course_id,semester需要从前端抢课时传来，is_seckill=1,status=NORMAL,selection_time=当前时间)

​			构建Message对象

​			发送事务消息	1



​			创建RocketMQLocalTransactionListener实现类

​				executeLocalTransaction执行本地事务（保存到数据库，更新数据库中的库存，将结果信息缓存到Redis中）

​					成功则，return RocketMQLocalTransactionState.COMMIT

​					失败则，return RocketMQLocalTransactionState.ROLLBACK

​				checkLocalTransaction事务 状态回查

​					根据消息内容查询数据库，判断数据库是否执行成功

​					return RocketMQLocalTransactionState.UNKNOWN;

​			

​			创建消费者RocketMQListener实现类

​			

​		监听秒杀结果		1

​			去查询Redis缓存的结果

​			去数据库查询结果（selections表）



​		退课时候要清除内存中的选课信息	1

​		退课时要添加库存 数据库，Redis，清除Redis中的秒杀结果信息	加锁

​		选完课程显示已选	1

​		抢课时有明显的等待显示		

​		

采用Redisson分布式锁完成数据库的更新（选课退课用同一把锁）





**预热阶段**：

提前缓存课程数据

采用分布式锁防止超卖

#### **异步处理**：

请求进入消息队列

后端顺序处理选课请求

**高并发处理**：

采用限流措施(令牌桶算法)

热点数据隔离(秒杀课程单独处理)

**失败重试**：

对暂时性错误提供有限次重试

**系统过载保护**：

自动降级策略(关闭非核心功能)

1. 页面静态化：课程列表静态缓存
2. 库存预热：秒杀课程数据提前加载至Redis
3. 分布式锁：防止超卖
4. 请求限流：避免系统崩溃
5. 异步处理：削峰填谷